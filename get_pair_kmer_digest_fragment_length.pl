#!/usr/bin/perl -w
use strict;
use Getopt::Long;

my $sUsage = qq(
perl $0 
  -pos  <kmer_pos_file, generated by get_kmer_in_fasta.pl>
  -kmer <kmer pair,  example:  ATGCGT,GCACGT>
);

die $sUsage unless @ARGV >= 2;

my ($file, $kmers);
GetOptions (
  "pos=s"  => \$file,
  "kmer=s" => \$kmers 
) or die("Error in command line arguments\n\n$sUsage");

my @kp;
if ($kmers){
  @kp = split /,/, $kmers;
  if(@kp != 2){die "Error: Need two kmers!\n" . $sUsage}
  my ($k1_aln, $k2_aln) = simple_aln(@kp);
  my $lop = largest_overlapping_seg($k1_aln, $k2_aln);
  print STDERR join("\t", @kp),"\n",  join("\t", $k1_aln, $k2_aln, $lop), "\n";
  print STDERR "Note: These two kmers are too similar (less then two mistches): ", join(" ", @kp), "\n" if  length($lop) >= 5 ;
}

my %pos = get_pos_from_file($file, @kp);

my @kmers_left = keys %pos;
my @kmers_right = keys %pos;
foreach my $kl (@kmers_left) {
    foreach my $kr (@kmers_right){
        next if min_distance($kl, $kr) < 3;
        
    }
}



## subroutines
sub get_pos_from_file {
  my ($f, @kp) = @_;
  open (my $IN, $f) or die $!;
  my %return;
  while(<$IN>){
    chomp;
    my @t = split /\,/,$_;
    my $kmer = $t[1];
    my $chr = $t[0];
    my $match = @kp?is_matching(@kp, $kmer):1;
    next unless $match;
    $return{$kmer}{$chr} = [ @t[2..$#t] ]; 
  }
  close $IN;
  return %return;
}

sub largest_overlapping_seg {
  my ($k1, $k2) = @_;
  my @arr;
  my $ind = -1;
  my $pre = 0;
  foreach my $i (0 .. length($k1)-1){
    if (substr($k1, $i,1) !~/-/ and substr($k2, $i, 1) eq substr($k1, $i,1)){ $ind++ if $pre==0; push @{$arr[$ind]}, substr($k1, $i, 1); $pre=1 }
    else{$pre=0}
  }
  if (scalar @arr>0){
    #print STDERR @{$arr[0]}, "\n";
    @arr = sort {scalar @$a <=> scalar @$b}@arr;
    return join("", @{$arr[-1]});
  }
  else{
    return ""
  }
}

sub min_distance {
  my ($k1_aln, $k2_aln) = @_;;
  my $dis = 0;
  foreach (my $i = 0; $i < length($k1_aln); $i++){
    $dis++ if substr($k1_aln, $i, 1) ne substr($k2_aln, $i, 1);
  }
  return $dis;
}

sub p {
  my ($aa1, $aa2) = @_;
  return ($aa1 eq $aa2)?1:-1;
}

sub simple_aln { ## Needleman-Wunsch Algorithm, very slow for long sequences, but should be OK iwth legnth < 10
    my ($s, $t) = @_;
    our  @M; ## similarity matrix;
    ## calculate similarity mattrix
    my ($i, $j); # indexes
    my $g = -2; ## gap penalty
    map{$M[$_][0] = $g * $_}0 .. length($s);
    map{$M[0][$_] = $g * $_}0 .. length($t);
    foreach $i (1 .. length($s)){
      foreach $j (1 .. length($t)){
        my $p = p(substr($s, $i-1, 1), substr($t, $j-1,1));
        $M[$i][$j] = max($M[$i-1][$j] + $g, $M[$i][$j-1]+$g, $M[$i-1][$j-1] + $p);
        #print join("\t", $i, $j, $M[$i][$j]),"\n";
      }
    }
    # map{print join("\t", @$_), "\n"}@M;
    # get Alignment
    #put([@M]);
    my ($k1_aln, $k2_aln) = getAlignment($s, $t, [@M]);
    return ($k1_aln, $k2_aln);
}
sub put {
  my ($ref) = @_;
  my @m = @$ref;
  map{print STDERR join(",", @$_),"\n"}@m;
}
sub randome_string {
  my $l = shift || 10;
  my $str;
  my @pool = ('a'..'z', 'A'..'Z',0..9);
  while($l > 0){
    $l --;
    $str .= $pool[int(rand(scalar @pool))];
  }
  return $str;
}

sub getAlignment {
    my ($s, $t, $arrref) = @_;
    #print STDERR "\$s, ", $s, " \$t, ", $t, "\n";
    my @M = @$arrref;
    my $g = -2;
    my ($i, $j) =  (length($s), length($t));
    return("-" x $j, $t) if $i == 0;
    return($s, "-" x $i) if $j == 0;
    my ($sLast, $tLast) = (substr($s, -1), substr($t, -1));
    if ($M[$i][$j] == $M[$i-1][$j-1] + p($sLast, $tLast)) {
      my ($sa, $ta) = getAlignment(substr($s, 0, -1), substr($t, 0, -1), $arrref);
      return($sa.$sLast, $ta.$tLast);
    }
    elsif($M[$i][$j] == $M[$i-1][$j] + $g){
      my ($sa, $ta) = getAlignment(substr($s, 0, -1), $t, $arrref);
      return($sa.$sLast, $ta."-");
    }
    else {
      my ($sa, $ta) = getAlignment($s, substr($t, 0, -1), $arrref);
      return($sa."-", $ta.$tLast); 
    }
}

sub max{
 my @arr = @_;
 my $max = shift @arr;
 map{$max = $_ if $_ > $max}@arr;
 return $max;
}

sub is_matching {
  my ($k1, $k2, $motif);
  return ($motif eq $k1 or $motif eq $k2)?1:0;
}
