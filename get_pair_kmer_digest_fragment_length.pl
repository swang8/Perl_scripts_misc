#!/usr/bin/perl -w
use strict;
use Getopt::Long;
use lib '/home/shichen.wang/perl5/lib/perl5';
use Parallel::ForkManager;

my $sUsage = qq(
perl $0 
  -pos  <kmer_pos_file, generated by get_kmer_in_fasta.pl>
  -kmer <kmer pair,  example:  ATGCGT,GCACGT>
  -output <output_file>
);

die $sUsage unless @ARGV >= 2;

my ($file, $kmers, $output);
GetOptions (
  "pos=s"  => \$file,
  "kmer=s" => \$kmers,
  "output=s" => \$output
) or die("Error in command line arguments\n\n$sUsage");

my $fh = IO::File->new($output, "w");
die "Error: cound not open $output for write.\n" unless defined $fh;

my @kp;
if ($kmers){
  @kp = split /,/, $kmers;
  if(@kp != 2){die "Error: Need two kmers!\n" . $sUsage}
  my ($k1_aln, $k2_aln) = simple_aln(@kp);
  my $lop = largest_overlapping_seg($k1_aln, $k2_aln);
  print STDERR join("\t", @kp),"\n",  join("\t", $k1_aln, $k2_aln, $lop), "\n";
  print STDERR "Note: These two kmers are too similar (less then two mistches): ", join(" ", @kp), "\n" if  length($lop) >= 5 ;
}

my $pm = Parallel::ForkManager->new(10);

print_time("Start");
my %pos = get_pos_from_file($file, @kp);
print_time("Done reading position file");

my @kmers_left = keys %pos;
my @kmers_right = keys %pos;
print STDERR "Total kmers: ", scalar @kmers_left, "\n";
mkdir("./tmp") unless -d "./tmp";
foreach my $kl (@kmers_left) {
    foreach my $kr (@kmers_right){
        print STDERR "Pair: ", $kl, " ", $kr, "\n";
        next if min_distance($kl, $kr) == 0;
        my @chrs = keys %{$pos{$kr}};
        my @tmp_files = ();
        foreach my $chr (@chrs){
            next if not exists $pos{$kl}{$chr};
            my $tmp = "./tmp/" . join(".", $kl, $kr,$chr, "tmp");
            push @tmp_files, $tmp;
            my $pid = $pm->start and next;
            my $pl = $pos{$kl}{$chr};
            my $pr = $pos{$kr}{$chr};
            my @fragments = get_fragment_length($pl, $pr);
            my %bin_count = bin_count(@fragments);
            open (my $TMP, ">$tmp") or die $!;
            map{print $TMP join("\t", $kl, $kr, $chr, $_, $bin_count{$_}), "\n"}sort{$a cmp $b}keys %bin_count;
            close $TMP;
            $pm->finish;
        }
        $pm->wait_all_children;
        append_to_output($fh, @tmp_files);
    }
}


### 
sub append_to_output {
  my $fh = shift;
  my @fs = @_;
  foreach my $f(@fs){
    open(F, $f) or die $!;
    while(<F>){
      print $fh $_;
    }
    close F;
    #unlink($f)
  }
}


sub bin_count {
    my @bins =  map{my $n = 250 + 50 * $_}0..14;
    my @count = map{0}1 .. (scalar (@bins) + 2);
    my @frags = @_;
    foreach my $l (@frags){
        if ($l < $bins[0]){$count[0]++}
        elsif ($l > $bins[-1]){$count[-1]++}
        else{
            my $ind = int(($l - 250 ) / 50);
            $ind ++ if $l > (250 + $ind * 50);
            #print STDERR $l, "\t", $ind, "\n";
            $count[$ind]++;
        }
    }
    map{print STDERR $_, "\t", $count[$_], "\n"}0..$#count;
    my %return;
    map{
        if($_ == 0){$return{"<250"} = $count[$_]}
        elsif($_ == $#count){$return{">1000"} = $count[$_]}
        else{my $s = 250 + 50 * ($_-1); my $e = 250 + 50 * $_; $return{join("-", $s, $e)} = $count[$_]}
    }0..$#count;
    return %return;
}

sub get_fragment_length {
  my ($pl, $pr) = @_;
  my @arr = sort {$a <=> $b} (@$pl, @$pr);
  my $i = 0;
  my @return;
  while ($i < scalar (@arr)){
      for (my $j = $i+1; $j < scalar @arr; $j++){
          last if $arr[$j] - $arr[$i] < 2000;
          push @return, $arr[$j] - $arr[$i]
      }
      $i++;
  }
  return @return;
}


sub get_pos_from_file {
  my ($f, @kp) = @_;
  open (my $IN, $f) or die $!;
  my %return;
  while(<$IN>){
    chomp;
    my @t = split /\,/,$_;
    my $kmer = $t[1];
    my $chr = $t[0];
    my $match = @kp?is_matching(@kp, $kmer):1;
    next unless $match;
    $return{$kmer}{$chr} = [ @t[2..$#t] ]; 
  }
  close $IN;
  return %return;
}

sub largest_overlapping_seg {
  my ($k1, $k2) = @_;
  my @arr;
  my $ind = -1;
  my $pre = 0;
  foreach my $i (0 .. length($k1)-1){
    if (substr($k1, $i,1) !~/-/ and substr($k2, $i, 1) eq substr($k1, $i,1)){ $ind++ if $pre==0; push @{$arr[$ind]}, substr($k1, $i, 1); $pre=1 }
    else{$pre=0}
  }
  if (scalar @arr>0){
    #print STDERR @{$arr[0]}, "\n";
    @arr = sort {scalar @$a <=> scalar @$b}@arr;
    return join("", @{$arr[-1]});
  }
  else{
    return ""
  }
}

sub min_distance {
  my ($k1_aln, $k2_aln) = @_;;
  my $dis = 0;
  foreach (my $i = 0; $i < length($k1_aln); $i++){
    $dis++ if substr($k1_aln, $i, 1) ne substr($k2_aln, $i, 1);
  }
  return $dis;
}

sub p {
  my ($aa1, $aa2) = @_;
  return ($aa1 eq $aa2)?1:-1;
}

sub simple_aln { ## Needleman-Wunsch Algorithm, very slow for long sequences, but should be OK iwth legnth < 10
    my ($s, $t) = @_;
    our  @M; ## similarity matrix;
    ## calculate similarity mattrix
    my ($i, $j); # indexes
    my $g = -2; ## gap penalty
    map{$M[$_][0] = $g * $_}0 .. length($s);
    map{$M[0][$_] = $g * $_}0 .. length($t);
    foreach $i (1 .. length($s)){
      foreach $j (1 .. length($t)){
        my $p = p(substr($s, $i-1, 1), substr($t, $j-1,1));
        $M[$i][$j] = max($M[$i-1][$j] + $g, $M[$i][$j-1]+$g, $M[$i-1][$j-1] + $p);
        #print join("\t", $i, $j, $M[$i][$j]),"\n";
      }
    }
    # map{print join("\t", @$_), "\n"}@M;
    # get Alignment
    #put([@M]);
    my ($k1_aln, $k2_aln) = getAlignment($s, $t, [@M]);
    return ($k1_aln, $k2_aln);
}
sub put {
  my ($ref) = @_;
  my @m = @$ref;
  map{print STDERR join(",", @$_),"\n"}@m;
}
sub randome_string {
  my $l = shift || 10;
  my $str;
  my @pool = ('a'..'z', 'A'..'Z',0..9);
  while($l > 0){
    $l --;
    $str .= $pool[int(rand(scalar @pool))];
  }
  return $str;
}

sub getAlignment {
    my ($s, $t, $arrref) = @_;
    #print STDERR "\$s, ", $s, " \$t, ", $t, "\n";
    my @M = @$arrref;
    my $g = -2;
    my ($i, $j) =  (length($s), length($t));
    return("-" x $j, $t) if $i == 0;
    return($s, "-" x $i) if $j == 0;
    my ($sLast, $tLast) = (substr($s, -1), substr($t, -1));
    if ($M[$i][$j] == $M[$i-1][$j-1] + p($sLast, $tLast)) {
      my ($sa, $ta) = getAlignment(substr($s, 0, -1), substr($t, 0, -1), $arrref);
      return($sa.$sLast, $ta.$tLast);
    }
    elsif($M[$i][$j] == $M[$i-1][$j] + $g){
      my ($sa, $ta) = getAlignment(substr($s, 0, -1), $t, $arrref);
      return($sa.$sLast, $ta."-");
    }
    else {
      my ($sa, $ta) = getAlignment($s, substr($t, 0, -1), $arrref);
      return($sa."-", $ta.$tLast); 
    }
}

sub max{
 my @arr = @_;
 my $max = shift @arr;
 map{$max = $_ if $_ > $max}@arr;
 return $max;
}

sub is_matching {
  my ($k1, $k2, $motif) = @_;;
  return ($motif eq $k1 or $motif eq $k2)?1:0;
}
sub print_time {
  my $m = shift;
  my $t = localtime(time);
  print STDERR $t,"\t", $m, " ...\n"; 
}
sub append {
    
}
